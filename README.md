# Planning System

Automated Desktop Application for Optimizing Exam Invigilation Scheduling

## Project Structure

This project follows a feature‑first Flutter structure with a small set of core, app‑wide modules. Below is what to put in each folder/file so the codebase stays clean and scalable.

### lib/

- `main.dart`

  - App entrypoint only. Wire up DI/bindings, themes, and the root navigator.
  - Uses `GetMaterialApp` with `getPages: AppRouter.getViews()`.

- `core/` (shared, app‑wide code; no feature specifics)

  - `utils/`
    - Cross‑cutting helpers and constants (formatters, validators, theme, etc.).
    - `app_router.dart`: Central routing. Define route name constants and register `GetPage` entries for each feature screen. Keep navigation logic here, not in views.
  - `models/`
    - Global domain models used across features (e.g., `User`, `Exam`).
    - Plain Dart classes with `fromJson/toJson` (optionally use Freezed/JsonSerializable later).
  - `common/`
    - Reusable UI components shared by many features (buttons, inputs, layout widgets).
  - `controllers/`
    - App‑wide controllers/services with global state (e.g., `ThemeController`, `SessionController`). Use GetX controllers here.
  - `interface/`
    - Abstract contracts (repositories/services) that features depend on (e.g., `ExamRepository`, `AuthService`).
  - `services/`
    - Concrete implementations of `interface/` contracts (API clients, local storage, platform integrations). No UI code.

- `features/` (vertical slices; everything scoped to a business feature)
  - `<feature>/`
    - `views/` — Screen widgets that map to routes (e.g., `HomeView`, `SettingsView`). Keep UI composition here; avoid heavy logic.
    - `widgets/` — Smaller UI components used by the feature’s views (cards, tiles, forms). Pure presentation where possible.
    - `controllers/` — Feature state and actions using GetX (`GetxController`). Fetch data via `interface/` contracts, expose `Rx` state, perform navigation via `AppRouter`.
    - `models/` — Models used only by this feature. If used by many features, move to `core/models`.

Platform folders `windows/` and `linux/` are generated by Flutter; you normally don’t modify them except for native window settings/icons.

---

## How to add a new screen (example)

1. Create a view file under `lib/features/<feature>/views/your_view.dart`:

   - Stateless/Stateful widget that builds the page UI.
   - Keep logic light; delegate state to a feature `GetxController` if needed.

2. (Optional) Create a controller under `lib/features/<feature>/controllers/your_controller.dart`:

   - Extend `GetxController`; expose `Rx` fields and actions.
   - Consume repositories from `core/interface` via DI.

3. Register the route in `lib/core/utils/app_router.dart`:

   - Add a route constant (e.g., `static const yourView = "/yourView";`).
   - Add a `GetPage` entry in `getViews()` that returns your view.

4. Navigate using:

   - `Get.toNamed(AppRouter.yourView);`

---

## Notes

- Routing: The project uses GetX routes (`GetMaterialApp` + `GetPage`) only. 
- Controllers should not depend on Flutter widgets. Keep business logic testable.
